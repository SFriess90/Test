# Tiny-Drone Fly-In Framework
# deps: pip install numpy pillow imageio

import math
import numpy as np
from PIL import Image, ImageDraw
import imageio.v2 as imageio

# ----------------------------
# Geometry & Projection
# ----------------------------
def normalize(v):
    n = np.linalg.norm(v)
    return v if n == 0 else v / n

def look_at(camera_pos, target, up=np.array([0.0, 0.0, 1.0])):
    """Return rotation R and translation t to transform world -> camera."""
    z_axis = normalize(target - camera_pos)           # forward
    x_axis = normalize(np.cross(z_axis, up))          # right
    if np.linalg.norm(x_axis) < 1e-8:
        up = normalize(np.array([0.0, 1e-3, 1.0]))
        x_axis = normalize(np.cross(z_axis, up))
    y_axis = np.cross(z_axis, x_axis)                 # true up
    R = np.vstack([x_axis, y_axis, z_axis])           # rows are axes
    t = -R @ camera_pos
    return R, t

def project_points(Pw, R, t, fx, fy, cx, cy, z_near=1e-3):
    """Perspective project world points to pixels; return u,v,zc,mask."""
    Pc = (R @ Pw.T).T + t
    zc = Pc[:, 2]
    in_front = zc > z_near
    inv_z = np.zeros_like(zc)
    inv_z[in_front] = 1.0 / zc[in_front]
    u = fx * Pc[:, 0] * inv_z + cx
    v = fy * Pc[:, 1] * inv_z + cy
    return u, v, zc, in_front

# ----------------------------
# Scene
# ----------------------------
def generate_plane_points(n_points=6000, area_half_extent=380.0, seed=14,
                          size_range=(0.7, 1.6)):
    """Random dots on z=0 with per-point albedo and size multiplier."""
    rng = np.random.default_rng(seed)
    x = rng.uniform(-area_half_extent, area_half_extent, size=n_points)
    y = rng.uniform(-area_half_extent, area_half_extent, size=n_points)
    z = np.zeros_like(x)
    albedo = rng.uniform(0.5, 0.9, size=n_points)                     # grey→white
    size_factors = rng.uniform(size_range[0], size_range[1], size=n_points)
    return np.stack([x, y, z], axis=1), albedo, size_factors

# ----------------------------
# Rendering
# ----------------------------
def render_frame(points_world, albedo, camera_pos, target,
                 size_factors=None,
                 # sprites:
                 sprite_img=None, sprite_positions=None, sprite_size_factors=None,
                 sprite_size_mode="projected",  # "projected" (1/zc) or "inverse_square"
                 img_w=720, img_h=405, fov_y_deg=60.0,
                 # points (inverse-quadratic size & brightness):
                 size_scale=1400.0, brightness_scale=3.0, eps=0.35,
                 # sprites (smooth size + inverse-square brightness):
                 sprite_size_scale=3.0,  # << tiny drone scale
                 sprite_brightness_scale=6.0,
                 max_pt_radius=6.0, max_sprite_px=480,
                 bg=(0, 0, 0)):
    """Render a frame with dotted plane + transparent sprites."""
    # Camera intrinsics from FOV
    fy = 0.5 * img_h / math.tan(math.radians(fov_y_deg * 0.5))
    fx = fy
    cx, cy = img_w * 0.5, img_h * 0.5
    R, t = look_at(camera_pos, target)

    img = Image.new("RGB", (img_w, img_h), color=bg)
    draw = ImageDraw.Draw(img, 'RGB')

    # --- Points ---
    u, v, zc, in_front = project_points(points_world, R, t, fx, fy, cx, cy)
    on_screen = (u >= -30) & (u < img_w + 30) & (v >= -30) & (v < img_h + 30)
    mask = in_front & on_screen
    if np.any(mask):
        Pw_vis = points_world[mask]
        d2 = np.sum((Pw_vis - camera_pos) ** 2, axis=1)
        inv_quad = 1.0 / (d2 + eps)                                   # 1/(d^2 + eps)
        radii = size_scale * inv_quad
        if size_factors is not None:
            radii = radii * size_factors[mask]
        radii = np.clip(radii, 0.5, max_pt_radius)
        brightness = np.clip(albedo[mask] + brightness_scale * inv_quad, 0.0, 1.0)
        pix_vals = (brightness * 255.0).astype(np.uint8)
        order = np.argsort(zc[mask])[::-1]                            # far→near
        for x, y, r, val in zip(u[mask][order], v[mask][order], radii[order], pix_vals[order]):
            draw.ellipse((int(x - r), int(y - r), int(x + r), int(y + r)),
                         fill=(int(val), int(val), int(val)))

    # --- Sprites ---
    if sprite_img is not None and sprite_positions is not None and len(sprite_positions) > 0:
        us, vs, zcs, in_front_s = project_points(sprite_positions, R, t, fx, fy, cx, cy)
        on_screen_s = (us >= -max_sprite_px) & (us < img_w + max_sprite_px) & \
                      (vs >= -max_sprite_px) & (vs < img_h + max_sprite_px)
        m = in_front_s & on_screen_s
        if np.any(m):
            Pw_s = sprite_positions[m]
            # Brightness: inverse-square (world distance)
            d2s = np.sum((Pw_s - camera_pos) ** 2, axis=1)
            invq = 1.0 / (d2s + eps)
            bright_mul = 1.0 + sprite_brightness_scale * invq

            # Size: perspective size by default (smooth 1/zc)
            if sprite_size_mode == "projected":
                z = np.maximum(zcs[m], 1e-3)
                base_px = sprite_size_scale * fx / z
            else:
                base_px = sprite_size_scale * invq  # legacy inverse-square size

            if sprite_size_factors is not None:
                base_px = base_px * sprite_size_factors[m]
            base_px = np.clip(base_px, 18, max_sprite_px).astype(np.int32)

            order = np.argsort(zcs[m])[::-1]  # far→near
            for x, y, px, bmul in zip(us[m][order], vs[m][order], base_px[order], bright_mul[order]):
                spr = sprite_img.resize((px, px), resample=Image.Resampling.BICUBIC)
                r, g, b, a = spr.split()
                rgb = np.stack([np.array(r), np.array(g), np.array(b)], axis=-1).astype(np.float32)
                rgb = np.clip(rgb * bmul, 0, 255).astype(np.uint8)
                spr_mod = Image.merge("RGBA", (Image.fromarray(rgb[:, :, 0]),
                                               Image.fromarray(rgb[:, :, 1]),
                                               Image.fromarray(rgb[:, :, 2]), a))
                img.paste(spr_mod, (int(x - px // 2), int(y - px // 2)), spr_mod)

    return img

# ----------------------------
# Animation
# ----------------------------
def fly_towards_point(points_world, albedo, incident_angle_deg=30.0, start_height=80.0,
                      speed_per_frame=8.0, n_frames=56, min_distance=0.8,
                      target=np.array([0.0, 0.0, 0.0]),
                      size_factors=None,
                      sprite_img=None, sprite_positions=None, sprite_size_factors=None,
                      sprite_size_mode="projected",
                      img_w=720, img_h=405, fov_y_deg=60.0,
                      size_scale=1400.0, brightness_scale=3.0, eps=0.35,
                      sprite_size_scale=3.0, sprite_brightness_scale=6.0,
                      max_pt_radius=6.0, max_sprite_px=480,
                      bg=(0, 0, 0), out_path="fly_drone_tiny.gif", fps=24):
    """Fly camera toward 'target' at 'incident_angle_deg' and save a GIF."""
    theta = math.radians(incident_angle_deg)
    d0 = start_height / max(math.sin(theta), 1e-6)  # start distance so z=start_height
    frames = []
    for i in range(n_frames):
        d = max(d0 - speed_per_frame * i, min_distance)
        camera_pos = np.array([-d * math.cos(theta), 0.0, d * math.sin(theta)])
        img = render_frame(points_world, albedo, camera_pos, target,
                           size_factors=size_factors,
                           sprite_img=sprite_img, sprite_positions=sprite_positions,
                           sprite_size_factors=sprite_size_factors,
                           sprite_size_mode=sprite_size_mode,
                           img_w=img_w, img_h=img_h, fov_y_deg=fov_y_deg,
                           size_scale=size_scale, brightness_scale=brightness_scale, eps=eps,
                           sprite_size_scale=sprite_size_scale, sprite_brightness_scale=sprite_brightness_scale,
                           max_pt_radius=max_pt_radius, max_sprite_px=max_sprite_px, bg=bg)
        frames.append(np.array(img))
    imageio.mimsave(out_path, frames, duration=1.0 / fps)
    return out_path

# ----------------------------
# DEMO: Tiny drone sprite (uses your uploaded PNG with transparency)
# ----------------------------
if __name__ == "__main__":
    # Load your drone sprite (replace path as needed)
    drone = Image.open("/mnt/data/0001.png").convert("RGBA")

    # Plane & dots
    points, albedo, size_factors = generate_plane_points(
        n_points=6000, area_half_extent=380.0, seed=14
    )

    # Place several drones along the approach path for clear perspective change
    sprite_positions = np.array([
        [-360,  60, 0],
        [-240,   0, 0],
        [-120, -30, 0],
        [ -30,  10, 0],
        [   0,   0, 0],
    ], dtype=float)
    sprite_size_factors = np.array([1.0, 1.1, 1.2, 1.4, 1.8], dtype=float)

    out = fly_towards_point(
        points, albedo,
        incident_angle_deg=30.0,     # medium angle
        start_height=80.0,
        speed_per_frame=8.0,
        n_frames=56,
        min_distance=0.8,
        size_factors=size_factors,
        sprite_img=drone,
        sprite_positions=sprite_positions,
        sprite_size_factors=sprite_size_factors,
        sprite_size_mode="projected",  # smooth perspective sizing
        img_w=720, img_h=405,
        sprite_size_scale=3.0,         # <<< tiny drone scale (make smaller/bigger here)
        out_path="fly_drone_tiny.gif",
        fps=24
    )
    print("Saved:", out)
