# starfield_flythrough_nopop.py
# Stars vary in intrinsic size/brightness. Apparent brightness is strictly 1/z^2.
# Spawns are pushed far back so stars brighten smoothly instead of popping.
# Optional temporal dithering reduces 8-bit quantization popping.

import os
import math
import numpy as np
from PIL import Image, ImageDraw

# --------------------------
# Tunable parameters
# --------------------------
WIDTH, HEIGHT     = 1280, 720
FPS               = 30
N_FRAMES          = 300
N_STARS           = 5000
FOV_DEG           = 70

# Depth range and motion
Z_NEAR_WRAP       = 0.8          # when star gets this close, respawn far away
Z_SPAWN_MIN       = 800.0        # far spawn range (push far to avoid pop-in)
Z_SPAWN_MAX       = 1600.0
SPEED_PER_FRAME   = 0.8
SEED              = 7

# Apparent size controls (intrinsic per-star size)
BASE_SIZE_SCALE   = 18.0
SIZE_JITTER_MIN   = 0.6
SIZE_JITTER_MAX   = 1.8
MIN_RADIUS        = 0.4
MAX_RADIUS        = 2.6

# Intrinsic luminosity distribution (log-uniform)
LUMINOSITY_MIN    = 5.0
LUMINOSITY_MAX    = 1200.0

# Display gamma (1.0 keeps it literal)
OUTPUT_GAMMA      = 1.0

OUT_DIR = "frames"

# --------------------------
# Setup
# --------------------------
np.random.seed(SEED)
os.makedirs(OUT_DIR, exist_ok=True)

fov_rad = math.radians(FOV_DEG)
f = 0.5 * HEIGHT / math.tan(0.5 * fov_rad)

# Use the FAR depth to choose x/y spread so far stars project near center
spread_xy = (Z_SPAWN_MAX * math.tan(0.5 * fov_rad)) * (WIDTH / HEIGHT) * 0.25

rng = np.random.default_rng(SEED + 1)

def quantize_with_temporal_dither(b_linear_0_255):
    """
    Convert linear brightness (float 0..255) to 8-bit using random dithering.
    Prevents hard 0->1 steps when values hover below 1.
    """
    b_floor = np.floor(b_linear_0_255)
    frac = b_linear_0_255 - b_floor
    promote = rng.random(frac.shape) < frac
    return (b_floor + promote).astype(np.uint8)

def sample_intrinsic_sizes(n):
    return np.random.uniform(SIZE_JITTER_MIN, SIZE_JITTER_MAX, size=n)

def sample_intrinsic_luminosity(n):
    log_min, log_max = np.log(LUMINOSITY_MIN), np.log(LUMINOSITY_MAX)
    return np.exp(np.random.uniform(log_min, log_max, size=n))

def spawn(n):
    x = np.random.uniform(-spread_xy, spread_xy, size=n)
    y = np.random.uniform(-spread_xy, spread_xy, size=n)
    z = np.random.uniform(Z_SPAWN_MIN, Z_SPAWN_MAX, size=n)
    size_k = sample_intrinsic_sizes(n)
    l
